# -*- coding: utf-8 -*-
"""ProyectoFinal_Miglioretti.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DA4RTRHNIGbiAt1edlXAMpJkH5WudYjH

#Proyecto:
#Prediccion de precios de vuelos


*   **Alumno:** Leandro Gabriel Miglioretti

*   **Profesores:** "Coderhouse" - Carrera de "Data Scientist"
      - Damian Dupueto
      - Luis Enrique Patiño Quiroz


###**Objetivo:**
<P>El siguiente proyecto tiene como objetivo principal establecer un sistema de prediccion de precios en base a un dataset elejido de Kaggle el cual contiene datos sobre los pasajes aereos de 6 ciudades altamente pobladas de India, las cuales son: Delhi, Mumbai, Kolkata, Chennai, Bangalore y Hyderabad. Entre las caracteristicas del conjunto de datos podemos observar que hay mas de 300.000 vuelos realizados entre el 11 de febrero y el 31 de marzo, correspondiente a 7 semanas, los cuales nos proporcionan fecha, hora de salida, ciudades de partida y destino, aeorlinea que realiza el transbordo, duracion del viaje, numero de escalas, clase economica de vuelo, y por ultimo, su costo en Rupias.</P><br>

#Situacion actual de las empresas aereas
##Contexto comercial:
##Contexto analitico:
##Problema comercial:

#Instalacion de librerias y ejecucion del entorno de trabajo:

###Instalacion de librerias: (Ejecutar una sola vez)
"""

######--Ejectuar solo en el entorno de Google Colab--######
#!pip install -q condacolab
#import condacolab
#condacolab.install()

######--Ejecutar ya sea en Google Colab o Jupyter Notebook--######
# Install GDAL and Geopandas (2 minutos)
#!apt install gdal-bin python-gdal python3-gdal --quiet
#!apt install python3-rtree --quiet
#!pip install descartes --quiet
#!pip install geopy
#!pip install plotly_express
#!pip install ipython-autotime

"""###Instalacion de librerias"""

#Comenzamos importando las librerias que vamos a utilizar:
#%load_ext autotime (no ejecutar)
import pandas as pd
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import seaborn as sns
import re
import io
import os
import geopy
from geopy.distance import geodesic
from geopy.distance import great_circle

"""#Analisis Exploratorio de Datos (EDA)

*   Comenzamos cargando el dataset previamente subido a Github
"""

url1 = 'https://raw.githubusercontent.com/leanmiglio/DataScienceProyectCoderhouse/main/business.csv'
url2 = 'https://raw.githubusercontent.com/leanmiglio/DataScienceProyectCoderhouse/main/Clean_Dataset.csv'
url3 = 'https://raw.githubusercontent.com/leanmiglio/DataScienceProyectCoderhouse/main/economy.csv'

"""###   Visualizamos los dataset:

* Primer Dataframe : Business
"""

df1 = pd.read_csv(url1)
df1

"""*   Segundo Dataframe: Clean_dataset"""

df2 = pd.read_csv(url2)
df2

"""*   Tercer Dataframe: Economy"""

df3 = pd.read_csv(url3)
df3

df1.iloc[2][7]

"""###Analisis exploratorio de datos (EDA)
En esta sección realizaremos un analisis generalizado para encontrar las caracteristicas de nuestros dataset's para luego comenzar a trabajar con ellos. Haremos los mismos pasos para los tres dataset's, posteriormente sacaremos conclusiones que nos seran de utilidad para seguir con la limpieza de datos y la realizacion de un analisis de mayor profundidad.

#### Dataset N°1 : Business

Tamaño, filas, columnas, tipos de datos
"""

#Informacion de los tipos de datos
df1.info()

#Tamaño del dataset
df1.shape

"""Nulos y cantidades"""

df1.count()

#Datos nulos
df1.isnull().sum()

"""#####Cantidad de aerolineas y representacion gráfica"""

tipos_aerolineas_bs = df1["airline"].unique()
tipos_aerolineas_bs = tipos_aerolineas_bs.tolist()
print(tipos_aerolineas_bs)

df1.airline.value_counts()

#Grafico de "CANTIDAD DE VUELOS POR AEROLINEA - "Business"
ax = sns.countplot(data = df1, x = "airline",palette='viridis')
ax.set_xticklabels(ax.get_xticklabels(),rotation=40,ha="right")
plt.title('Cantidad de vuelos por aerolinea - "Business"', size = 15)

plt.show()

"""##### Cantidad de ciudades y representacion grafica

Ciudades de IDA
"""

tipos_ciudades_ida = df1["from"].unique()
tipos_ciudades_ida = tipos_ciudades_ida.tolist()
print(tipos_ciudades_ida)

df1["from"].value_counts()

#Grafico de "CANTIDAD DE VUELOS DESDE LAS CIUDADES - "BUSINESS"
ax = sns.countplot(data = df1, x = "from",palette='viridis')
ax.set_xticklabels(ax.get_xticklabels(),rotation=40,ha="right")
plt.title('Cantidad de vuelos desde las ciudades - "Business"', size = 15)

plt.show()

"""Ciudades de VUELTA"""

tipos_ciudades_vuelta = df1["to"].unique()
tipos_ciudades_vuelta = tipos_ciudades_vuelta.tolist()
print(tipos_ciudades_vuelta)

df1["to"].value_counts()

#Grafico de "CANTIDAD DE VUELOS HACIA LAS CIUDADES - "Business"
ax = sns.countplot(data = df1, x = "to",palette='viridis')
ax.set_xticklabels(ax.get_xticklabels(),rotation=40,ha="right")
plt.title('Cantidad de vuelos hacia las ciudades - "Business"', size = 15)

plt.show()

"""Grafico de cantidad de vuelos a ciudades IDA vs Vuelta"""



"""#### Grafico de las series de tiempo"""

#Convertimos la columna a tipo Datatime64ns
df1['date'] = pd.to_datetime(df1['date'])
print(df1.dtypes)
df1.head()

#GRAFICO DE LAS SERIES DE TIEMPO DE "Business"
df1['price']=df1['price'].replace([","],[""])
#df1["price"] = pd.to_numeric(df1["price"].replace(',', ''))
plt.style.use('dark_background')
plt.figure(figsize=(20,8))
sns.lineplot(data=df1,x='date',y=df1['price'],hue='airline',palette='hls')
plt.title('Precio del pasaje',fontsize=20)
plt.xlabel('Duration',fontsize=15)
plt.ylabel('Price',fontsize=15)

plt.show()

"""##### Cantidad de paradas: Dataset BUSINESS

Verificamos la cantidad de valores unicos de paradas que existen
"""

tipos_paradas_bs = df1["stop"].unique()
tipos_paradas_bs = tipos_paradas_bs.tolist()
print(tipos_paradas_bs)

"""Calculamos la cantidad de paradas por tipo y creamos dos listas para los indices y la data"""

stops_bs=df1["stop"].value_counts()
stops1_bs=pd.Series(stops_bs)
indices_stops_bs=stops1_bs.index.tolist()
data_stops_bs=stops_bs.tolist()

print(indices_stops_bs)
print(data_stops_bs)

#LIMPIEZA DE LOS NOMBRES DE LAS PARADAS
new_tipos_paradas_bs=[]
tipos_paradas_bs=indices_stops_bs
for i in range(len(tipos_paradas_bs)):

    if len(tipos_paradas_bs[i])==len(tipos_paradas_bs[0]):
         clean_tipos_paradas_bs=1
    elif len(tipos_paradas_bs[i])==len(tipos_paradas_bs[1]):
      clean_tipos_paradas_bs=0
    elif len(tipos_paradas_bs[i])==len(tipos_paradas_bs[2]):
      clean_tipos_paradas_bs=2
    else:
      new_text_bs=[]
      ctp_bs=tipos_paradas_bs[i]
      text_bs=str(ctp_bs[23::])
      new_text_bs=text_bs.split("\n")
      text1_bs=new_text_bs[0]
      clean_tipos_paradas_bs=str("1-" + text1_bs)

    new_tipos_paradas_bs.append(clean_tipos_paradas_bs)

print(new_tipos_paradas_bs)

"""Creamos un nuevo dataframe con los datos en limpio llamado "stops_Business"
"""

stops_Business=pd.DataFrame({'Cantidad': data_stops_bs, 'Tipo':new_tipos_paradas_bs})
stops_Business

"""Realizamos la grafica:"""

sns.set(rc = {'figure.figsize':(18,7)})
plt.yscale('log')

ax = sns.barplot(data = stops_Business,x='Tipo',y='Cantidad',palette='viridis')
ax.set_xticklabels(ax.get_xticklabels(),rotation=40,ha="right")
plt.title('CANTIDAD DE VUELOS POR PARADAS - "Business"', size = 15)
for index, row in stops_Business.iterrows():
    ax.text(row.name, row.Cantidad, round(row.Cantidad, 2), color='black', ha="center")

plt.show()

"""#### Dataset N°3 : Economy

Tamaño, filas, columnas, tipos de datos
"""

#Informacion de los tipos de datos
df3.info()

#Tamaño del dataset
df3.shape

"""Nulos y cantidades"""

df3.count()

#Datos nulos
df3.isnull().sum()

"""#####Cantidad de aerolineas y representacion gráfica"""

tipos_aerolineas_ec = df3["airline"].unique()
tipos_aerolineas_ec = tipos_aerolineas_ec.tolist()
print(tipos_aerolineas_ec)

df3.airline.value_counts()

#Grafico de "CANTIDAD DE VUELOS POR AEROLINEA - "Economy"
ax = sns.countplot(data = df3, x = "airline",palette='viridis')
ax.set_xticklabels(ax.get_xticklabels(),rotation=40,ha="right")
plt.title('Cantidad de vuelos por aerolinea - "Economy"', size = 15)

plt.show()

"""##### Cantidad de ciudades y representacion grafica

Ciudades de IDA
"""

tipos_ciudades_ida_ec = df3["from"].unique()
tipos_ciudades_ida_ec = tipos_ciudades_ida_ec.tolist()
print(tipos_ciudades_ida_ec)

df3["from"].value_counts()

#Grafico de "CANTIDAD DE VUELOS DESDE LAS CIUDADES - "Business"
ax = sns.countplot(data = df3, x = "from",palette='viridis')
ax.set_xticklabels(ax.get_xticklabels(),rotation=40,ha="right")
plt.title('Cantidad de vuelos desde las ciudades - Economy"', size = 15)

plt.show()

"""Ciudades de VUELTA"""

tipos_ciudades_vuelta_ec = df3["to"].unique()
tipos_ciudades_vuelta_ec = tipos_ciudades_vuelta_ec.tolist()
print(tipos_ciudades_vuelta_ec)

df3["to"].value_counts()

#Grafico de "CANTIDAD DE VUELOS HACIA LAS CIUDADES - "Economy"
ax = sns.countplot(data = df3, x = "to",palette='viridis')
ax.set_xticklabels(ax.get_xticklabels(),rotation=40,ha="right")
plt.title('Cantidad de vuelos hacia las ciudades - "Economy"', size = 15)

plt.show()

"""Grafico de cantidad de vuelos a ciudades IDA vs Vuelta

##### Cantidad de paradas: Dataset ECONOMY

Verificamos la cantidad de valores unicos de paradas que existen
"""

tipos_paradas_ec = df3["stop"].unique()
tipos_paradas_ec = tipos_paradas_ec.tolist()
print(tipos_paradas_ec)

"""Calculamos la cantidad de paradas por tipo y creamos dos listas para los indices y la data"""

stops_ec=df3["stop"].value_counts()
#price_total_stop_ec=df3["price"].sum()
stops1_ec=pd.Series(stops_ec)
indices_stops_ec=stops1_ec.index.tolist()
#price1_total_stop_ec=pd.Series(price_total_stop_ec)
data_stops_ec=stops_ec.tolist()
#data_sum_price_stop_ec=price_total_stop_ec.tolist()

print(indices_stops_ec)
print(data_stops_ec)
#print(price1_total_stop_ec)

df3['price'] = df3['price'].astype('str').str.replace(",", "").astype(str)
df3['price'] = pd.to_numeric(df3['price'],errors = 'coerce')
df3["price"]

#LIMPIEZA DE LOS NOMBRES DE LAS PARADAS
new_tipos_paradas_ec=[]
tipos_paradas_ec=indices_stops_ec
for i in range(len(tipos_paradas_ec)):

    if len(tipos_paradas_ec[i])==len(tipos_paradas_ec[0]):
         clean_tipos_paradas_ec=1
    elif len(tipos_paradas_ec[i])==len(tipos_paradas_ec[1]):
      clean_tipos_paradas_ec=0
    elif len(tipos_paradas_ec[i])==len(tipos_paradas_ec[2]):
      clean_tipos_paradas_ec=2
    else:
      new_text_ec=[]
      ctp_ec=tipos_paradas_ec[i]
      text_ec=str(ctp_ec[23::])
      new_text_ec=text_ec.split("\n")
      text1_ec=new_text_ec[0]
      clean_tipos_paradas_ec=str("1-" + text1_ec)

    new_tipos_paradas_ec.append(clean_tipos_paradas_ec)

print(new_tipos_paradas_ec)

mean_price_stop=[]

"""Creamos un nuevo dataframe con los datos en limpio llamado "stops_Business"
"""

stops_Economy=pd.DataFrame({'Cantidad': data_stops_ec, 'Tipo':new_tipos_paradas_ec})
stops_Economy

"""Realizamos la grafica:"""

sns.set(rc = {'figure.figsize':(18,7)})
plt.yscale('log')

ax = sns.barplot(data = stops_Economy,x='Tipo',y='Cantidad',palette='viridis')
ax.set_xticklabels(ax.get_xticklabels(),rotation=40,ha="right")
plt.title('CANTIDAD DE VUELOS POR PARADAS - "Economy"', size = 15)
for index, row in stops_Economy.iterrows():
    ax.text(row.name, row.Cantidad, round(row.Cantidad, 2), color='black', ha="center")

plt.show()

"""### Conclusiones del EDA

Luego de realizar un analisis de los datasets obtenidos en Kaggle, podemos observar que los datos de los dataset n°3:"Economy" y n°1:"Business" se desprenden del dataset n°2: "Clean_Dataset", a continuacion un listado con la diferencias encontradas:
*   En Clean_Dataset no esta la fecha exacta de salida, si no que nos proveen
los dias restantes que pasaron desde la fecha del 11 de febrero del 2022, cuando en los otros dos datasets se provee el dia en formato MM/DD/YY o DD/MM/YY
*   En Clean_Dataset nos proveen el rango horario diario en la que salieron y arrivaron los vuelos, en cambio en los otros datasets nos proveen la hora exacta de ambos
*   Los precios de los pasajes en "Business" y "Economy" estan separados con "comas" (ej, 23,530) cuando en Clean_Dataset esta sin comas (ej, 23530)
*   Las paradas tienen otro formato en Clean_Dataset siendo alfanumerico y sin la ciudad intermedia de destino en cuyo caso hubo 1 parada o mas.

Tambien podemos observar un error muy importante en el grafico de las series de tiempo para el dataset n°1 "Business". Se nos presenta un rango de fechas que va desde 02/22 hasta 11/22, lo cual es erroneo ya que la zona temporal en la que sucede esta comprendida a lo largo de 7 semanas entre Febrero y Marzo.

Para solucionar todos estos errores, concatenaremos los dos datasets derivados del original df°2, para obtener aquellos valores que son mas precisos y nos seran de utilidad como la hora exacta de salida y llegada, la fecha exacta, las ciudades intermedias de parada. Tambien realizaremos una adecuacion de las fechas para que tengan el rango de fechas real que va desde febrero a marzo. Pasaremos aquellos valores que estan en formato "object" a un formato conveniente como por ejemplo la duracion del viaje a formato "timedelta64"ns, como asi tambien la hora de llegada y salida, el precio a "int64", y especificaremos en el dataset nuevo concatenado que crearemos, si los vuelos son ejecutivos o economicos.
Tambien sumaremos algunos datos que nos pueden ser de utilidad, los cuales obtendremos de fuentes externas como:
*   La distancia total recorrida por el avion
*   La paridad Rupia/Dolar a el dia de emitidos los pasajes
*   Sucesos climaticos que puedan inferir, como tormentas electricas, tifones, niebla, neblina, tornados, indundaciones, vientos fuertes, granizo, etc.
*   El precio del petroleo y el combustible de aviones al dia
*   Sucesos relacionados al mundo financiero como variaciones de las cotizaciones de las empresas interdiarias o movimientos extraordinarios de indices macroeconomicos de India
*   El dia de la semana en la que salieron los vuelos (Lunes, Martes, etc...)
*   Restricciones relacionadas al covid-19 o la actual guerra entre Rusia y Ucrania

# Data Wrangling

## Unificacion del dataset

A continuacion concatenaremos los dataset "Economy" y "Business" agregando la siguientes columna:
*   **class**:  tipo de vuelo/clase (Economico o Ejecutivo)

Concatenaremos los datasets uno arriba de otro, ya que coinciden con las columnas entre si por tratarse de los mismos tipos de datos.

Agregamos una nueva columna a cada df con su tipo de vuelo
"""

df1.insert(11,"class","bs")  #Business
df3.insert(11,"class","ec")  #Economy

#Visualizamos la nueva columna insertada correctamente
df1.head()

"""Concatenacion:"""

dg=pd.concat([df1,df3],axis=0).reset_index(drop=True)

"""Dataset General: 300261 filas x 12 columnas"""

dg.info()

"""## Adecuacion de los datos

### Manejo de la columna "price"

La columna "price" nos muestra el precio de los vuelos.
El formato en el que se encuentra esta columna, "object", no nos permite realizar operaciones matematicas. Procederemos a transformaral en tipo "int64"
"""

dg['price'] = dg['price'].astype('str').str.replace(",", "").astype(str)
dg['price'] = pd.to_numeric(dg['price'],errors = 'coerce')

dg['price'].head()

"""### Manejo de la columna "stop"

En la columna "stop" los datos estan en un formato ilegible, lo que haremos sera utilizar los arrays donde previamente en el EDA procesamos los datos para reemplazarlos en el nuevo dataset general para que sea mas entendible, y a su vez poder crear una nueva columna llama: **int_city** (ciudad intermedia), la cual deriva de la string por la cual reemplazaremos los datos.
"""

print("Datos Business")
print(tipos_paradas_bs)
print(new_tipos_paradas_bs)

print(len(tipos_paradas_bs))
print(len(new_tipos_paradas_bs))

print("Datos Economy")
print(tipos_paradas_ec)
print(new_tipos_paradas_ec)

print(len(tipos_paradas_ec))
print(len(new_tipos_paradas_ec))

dg["stop"]=dg["stop"].replace(tipos_paradas_bs,new_tipos_paradas_bs)
dg["stop"]=dg["stop"].replace(tipos_paradas_ec,new_tipos_paradas_ec)

"""### Transformacion de la columna "date" de datatype "*objet*" a datatype "*datetime*"

El objetivo es poder trabajar la linea de tiempo con valores numericos encuadradas en un formato de fecha.
<br>Si bien en la columna se visualiza una fecha formada por numeros a los cuales hacen referencia a año/mes/dia, no podemos utilizarlo para realizar calculos de tipo fecha porque no posee los atributos necesarios, ya que al tratarse de tipo "*object*" no posee las cualidades que un formato "*datetime*" tiene.
"""

#Dataframe N°1: Business
dg['date'] = pd.to_datetime(dg['date'],errors = 'coerce')

pd.set_option('display.max_rows', None)
dg[["date"]].iloc[:300000]

"""Luego de analizar detenidamente las fechas del dataset "Business" el cual contiene 93486 filas, se puede concluir que los vuelos van desde el 11/02 hasta el 31/03. Tambien se identficaron dos formatos de fechas en la columna "date", los cuales son <b>year-month-day</b> y <b>year-day-month</b>.<br><br> Para poder realizar los graficos correspondientes necesitamos tener todas las fechas en un unico formato, por lo cual optamos por <b>"year-month-day"</b>.<br><br> A su vez, en el rango de fechas disponibles podemos visualizar que las fechas que van de <b>11/02 al 12/02</b>, y desde el <b>01/03 al 12/03</b>, tienen como formato de fecha year-day-month. Estas fechas en la columna "date" las cambiaremos por el formato elejido "year-month-day"."""

#Generamos dos listas que contengan las fechas viejas y las fechas nuevas respectivamente.

#formato requerido--->   'a','b','c'...
old_date=['2022-02-11','2022-02-12']
new_date=['2022-11-02 00:00:00','2022-12-02 00:00:00']


#Marzo 01 al 09 Old_DATE
for i in range(1,10,1):
    old_date_march=['2022-0',i,'-03']
    odM="".join([str(od_mm) for od_mm in old_date_march])
    old_date.append(odM)
#    print(old_date_march)
#    print(odM)
#    print(i)


#Marzo 01 al 09 New_DATE
for i in range(1,10,1):
    new_date_march=['2022-03-0',i,' 00:00:00']
    ndM="".join([str(nd_mm) for nd_mm in new_date_march])
    new_date.append(ndM)
#    print(old_date_march)
#    print(ndM)
#    print(i)
#print(new_date_string_march)

old_date.append('2022-10-03')                  #¿Hay alguna forma de simplificar esto????????
old_date.append('2022-11-03')
old_date.append('2022-12-03')
old_date.append('2022-10-02')
old_date.append('2022-11-02')
old_date.append('2022-12-02')

new_date.append('2022-03-10 00:00:00')
new_date.append('2022-03-11 00:00:00')
new_date.append('2022-03-12 00:00:00')
new_date.append('2022-02-10 00:00:00')
new_date.append('2022-02-11 00:00:00')
new_date.append('2022-02-12 00:00:00')
print(old_date)

print(new_date)

#Reemplazamos los valores de fecha viejos por los nuevos en el dataset general
dg["date"]=dg["date"].replace(old_date,new_date)

"""Podemos observar que se han cambiado correctamente, estando en formato "object"
"""

dg["date"]

"""Ahora graficaremos el grafico que previamente mostraba anualizado el rango de fechas, esta vez deberia visualizarse solamente los meses de Febrero y Marzo"""

#GRAFICO DE LAS SERIES DE TIEMPO DEL DATASET GENERAL
plt.style.use('dark_background')
plt.figure(figsize=(20,8))
sns.lineplot(data=dg,x=dg['date'].astype(str),y=dg['price'],hue='airline',palette='hls')
plt.title('Precio del pasaje',fontsize=20)
plt.xlabel('Duration',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.xticks(rotation=90)
plt.show()

"""Por ultimo transformaremos el conjunto de datos de formato "Object" a "datetime64"
"""

dg['date'] = pd.to_datetime(dg['date'],errors = 'coerce')

"""### Transformacion de las columnas "dep_time" y "arr_time" en formato Timedelta."""

#Transformamos la columna "dep_time" a formato Timedelta
dg['dep_time'] = dg['dep_time'].astype('str')
s_dt=dg['dep_time']
v_dt = s_dt.str.split(':', expand=True).astype(int)
dg['dep_time'] = pd.to_timedelta(v_dt[0], unit='h') + pd.to_timedelta(v_dt[1], unit='m')

#Transformamos la columna "arr_time" a formato Timedelta
dg['arr_time'] = dg['arr_time'].astype('str')
s_at=dg['arr_time']
v_ar = s_at.str.split(':', expand=True).astype(int)
dg['arr_time'] = pd.to_timedelta(v_ar[0], unit='h') + pd.to_timedelta(v_ar[1], unit='m')

#Visualizamos que se hayan corregido correctamente
dg.info()
dg.head()

"""### A continuacion transformaremos la columna "time_taken" a datatype "Timedelta"."""

#Transformamos la columna "time_taken" a formato Timedelta
#dg['time_taken'] = dg['time_taken'].astype('str')
#s_tt=dg['time_taken']
#v_tt = s_tt.str.split(' |h|m', expand=True).astype(str)

#dg['time_taken'] = pd.to_timedelta(v_tt[0].astype(int), unit='h') + pd.to_timedelta(v_tt[2].astype(int), unit='m')

"""Ejecutando el codigo anterior, se nos presento el siguiente error:

**#ValueError:** invalid literal for int() with base 10: '1.03', esto es debido a que por un error en la carga de los datos en el dataset se cargo un horario como formato float, el cual no es admitido para la operacion pd.to_timedelta. Procederemos a corregir el error...

Para corregirlo por sus correspondientes valores calcularemos la diferencia entre arr_time y dep_time, sabiendo que esta resta es igual al tiempo de duracion de vuelo (time_taken).<br>Crearemos una nueva celda donde manejaremos una rutina de errores y exepciones de forma automatizada para cuando se ingrese un nuevo dato, considere el error y lo adapte.
"""

#Transformamos la columna "time_taken" a formato Timedelta
try:
  dg['time_taken'] = dg['time_taken'].astype('str')
  s_tt=dg['time_taken']
  v_tt = s_tt.str.split(' |h|m', expand=True).astype(str)

  dg['time_taken'] = pd.to_timedelta(v_tt[0].astype(int), unit='h') + pd.to_timedelta(v_tt[2].astype(int), unit='m')
except ValueError:
  dg["time_taken"] = dg["arr_time"]-dg["dep_time"]

"""### Re-Adaptacion de las columnas departure y arrive utilizando dep_time y tike_taken

Con el objetivo de que en las columnas "departure" y "arrive" este presente la fecha, haremos una suma de el dia/mes/año con la hora/minuto.
"""

dg['departure']=dg['date']+dg['dep_time']
dg['arrive']=dg['departure']+dg['time_taken']

"""### Numero de vuelo

Uniremos los codigos de vuelos en un solo para poder trabajar posteriormente con estos, creando una nueva columna llamada: **num_flight**

No eliminaremos "ch_code" y "num_code" debido a que nos seran de utilidad a la hora de expandir los datos.
"""

dg['num_flight']=dg['ch_code'].astype(str)+dg['num_code'].astype(str)

dg.iloc[52]

"""### Extraccion de las ciudades intermedias de paradas

Para posteriormente calcular las distancias entre  necesitaremos las ciudades intermedias

## Expansion de los datos

### Calculo de las distancias entre las ciudades

Para calcular las distancias entre las ciudades y el recorrido total del vuelo, necesitaremos encontrar las latitudes y longitudes de todos los aeropuertos intermedios por los que pasaron los vuelos.

Podemos visualizar luego de realizar una investigacion en internet que los datos de los aeropuertos se dan en dos formatos: ciudad (ej. Bhubaneswar) o en codigo IATA (ej. ITX).

Para eso descargaremos un dataset que contiene los datos en codigo IATA de nuestros aeropuertos, donde se visualizan sus latitudes, longitudes, a que ciudad corresponde, que tipo de aeropuerto es, y algunos datos extras.

Creditos: Kaggle

https://www.kaggle.com/datasets/open-flights/airports-train-stations-and-ferry-terminals?resource=download

Dataset **"airports-extended"**: dae
"""

dae=pd.read_csv("https://raw.githubusercontent.com/leanmiglio/DataScienceProyectCoderhouse/main/airports-extended.csv", names=["airport_ID", "name_airport", "city", "country", "IATA", "ICAO", "lat","lon","altitude","timezone","DST","TZ_region","type","source"])
dae.head()

dae.info()

dae[dae.city=='Hyderabad']

dae[(dae.city=='Hyderabad') & (dae.country=="India")]

dae[(dae.city=='Hyderabad') & (dae.country=="India") & (dae.country=='')]

type_stop_dg=[]
stop_list_dg=dg["stop"].unique()
stop_list_dg=stop_list_dg.tolist()
print(stop_list_dg)
cant_stops=len(stop_list_dg[2::])
for i in range( cant_stops ):

    a=stop_list_dg[i+2]
    print(a)
    if a==2:
        a=str(a)
    else:
        name=a[2::]
        name=str(name)
        type_stop_dg.append(name)

print(type_stop_dg)

for i in range(len(type_stop)):
    len=len(type_stop[i])
    print(len)

print(type_stop_dg[1])
a=type_stop_dg[1]
a=str(a)
print(a)
print(len("string"))
ln=len(a)
print(ln)



print(type_stop_dg)
cant_st=len(type_stop_dg)
for i in range(cant_st):
    ln=len(type_stop_dg[i])
    print(type_stop_dg[i])
    dato=str(type_stop_dg[i])
    print(dato)

    if ln==3:
        a=dae[(dae.country=="India") & (dae.type=='airport') & (dae.IATA==dato)]
        print(a)
        print("MEDIANTE CODIGO IATA")
        print(a.shape[0])
        print("numero de indice",a.index.tolist())
        print("cantidad de coincidencias:", len(a.index.tolist()))
        print("-------------------------------------------------------------------------------------------------------")
        print("-------------------------------------------------------------------------------------------------------")
    elif ln!=3:
        a=dae[(dae.country=="India") & (dae.type=='airport') & (dae.city==dato)]
        print(a)
        print("MEDIANTE CODIGO CITY")
        print(a.shape[0])
        print("numero de indice", a.index.tolist())
        print("cantidad de coincidencias:", len(a.index.tolist()))
        print("-------------------------------------------------------------------------------------------------------")
        print("-------------------------------------------------------------------------------------------------------")

dato="IXR"
a=dae[(dae.country=="India")& (dae.IATA==dato)]
print(a)
a.loc[2912,"lat"]
print(a.shape)
print(a.shape[0])

"""CHENAI 0
PATNA 0
JRG 0
JGB 0

HYDERABAD 2
DELHI 2

*   **hour_range_dep**: rango horario de partida (vespertino, nocturno, etc)
*   **hour_range_arr**: rango horario de llegada (vespertino, nocturno, etc)
*   arr_time
*   date
"""

print(len(stop_list_dg[2::]))

"""# Analisis estadistico y obtencion de insights"""



"""# Preguntas:"""





"""#Implementacion de un modelo de regresion lineal"""



"""# Implementacion de un clasificador"""



"""opensky

Miglioretti
438jdhKE82LS91kfd3
"""